pub mod values;
use rand::distr::SampleString as _;
pub use values::KnownOptions;

use chrono::{DateTime, Utc};
use dioxus_stores::Store;
use serde::{Deserialize, Serialize};

/// Very funny type we use to give random uids to list items at deserialize time.
#[derive(Debug, Clone, PartialEq)]
pub struct UID(pub String);

impl core::fmt::Display for UID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl UID {
    pub fn new() -> Self {
        UID(rand::distr::Alphanumeric.sample_string(&mut rand::rng(), 10))
    }
}

impl Default for UID {
    fn default() -> Self {
        Self::new()
    }
}

impl<'de> Deserialize<'de> for UID {
    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Ok(Self::new())
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct IngredientAllowedUnit {
    pub id: String,
    pub name: String,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub abbreviation: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<String>,
}

impl IngredientAllowedUnit {
    pub fn as_reference_unit(self) -> ReferenceUnit {
        ReferenceUnit {
            id: self.id,
            abbreviation: self.abbreviation.unwrap_or_default(),
            name: self.name,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct Ingredient {
    pub id: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct Author {
    pub image: String,
    pub name: String,
    pub url: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ForkedIntoOtherLocale {
    pub id: String,
    pub locale: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferenceUnit {
    pub abbreviation: String,
    pub id: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferencePreparation {
    /// dummy UID generated by serde, to give us unique IDs in the UI
    #[serde(default, skip_serializing)]
    pub uid: UID,

    pub id: String,
    pub name: String,
}

#[serde_with::serde_as]
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct RecipeIngredient {
    /// dummy UID generated by serde, to give us unique IDs in the UI
    #[serde(default, skip_serializing)]
    pub uid: UID,

    pub quantity: Quantity,
    pub reference_ingredient: Ingredient,

    #[serde_as(deserialize_as = "serde_with::DefaultOnNull")]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub reference_preparations: Vec<ReferencePreparation>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_text: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferenceTag {
    pub category: String,
    pub id: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct CapabilityPhase {
    pub can_follow_phases: Vec<String>,
    pub id: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferenceCapability {
    pub id: String,
    pub name: String,
}

#[derive(
    Debug, Serialize, Deserialize, Copy, Clone, PartialEq, strum::Display, strum::EnumString,
)]
pub enum ReferenceSettingId {
    #[serde(rename = "kitchenos:Kenwood:KeepWarmSetting")]
    KeepWarm,

    #[serde(
        rename = "kitchenos:Kenwood:TemperatureSetting",
        alias = "cckg:InternalTemperatureSetting",
        alias = "cckg:TemperatureSetting"
    )]
    Temperature,

    #[serde(rename = "kitchenos:Kenwood:SpeedSetting")]
    Speed,

    #[serde(rename = "kitchenos:Kenwood:TimeSetting", alias = "cckg:TimeSetting")]
    Time,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferenceSetting {
    pub id: ReferenceSettingId,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct ReferenceValue {
    pub id: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
#[serde(tag = "type")]
pub enum SettingValue {
    #[serde(rename = "numeric")]
    Numeric {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reference_unit: Option<ReferenceUnit>,
        text: String,
        value: f64,
    },

    #[serde(rename = "boolean")]
    Boolean { text: String, value: bool },

    #[serde(rename = "nominal")]
    Nominal {
        text: String,
        reference_value: ReferenceValue,
    },
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct CapabilitySetting {
    /// dummy UID generated by serde, to give us unique IDs in the UI
    #[serde(default, skip_serializing)]
    pub uid: UID,

    pub reference_setting: ReferenceSetting,
    pub value: SettingValue,
}

#[serde_with::serde_as]
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct StepCapability {
    pub phase: CapabilityPhase,
    pub reference_capability: ReferenceCapability,

    #[serde_as(deserialize_as = "serde_with::DefaultOnNull")]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub settings: Vec<CapabilitySetting>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct Quantity {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount: Option<f64>,
    pub reference_unit: ReferenceUnit,
    pub text: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct StepIngredient {
    /// dummy UID generated by serde, to give us unique IDs in the UI
    #[serde(default, skip_serializing)]
    pub uid: UID,

    pub ingredient_idx: u8,
    pub quantity: Quantity,
}

#[serde_with::serde_as]
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct RecipeStep {
    /// dummy UID generated by serde, to give us unique IDs in the UI
    #[serde(default, skip_serializing)]
    pub uid: UID,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capability: Option<StepCapability>,

    #[serde_as(deserialize_as = "serde_with::DefaultOnNull")]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ingredients: Vec<StepIngredient>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_text: Option<String>,
    pub text: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct Recipe {
    pub author: Author,
    pub created_at: DateTime<Utc>,
    pub created_by_id: String,
    pub description: String,
    pub etag: String,
    pub forked_into_other_locales: Vec<ForkedIntoOtherLocale>,
    pub id: String,
    pub ingredients: Vec<RecipeIngredient>,
    pub locale: String,
    pub modified_at: DateTime<Utc>,
    pub name: String,
    pub organization_id: String,
    pub published_at: DateTime<Utc>,
    pub reference_tags: Vec<ReferenceTag>,
    pub serves: u8,
    pub state: String,
    pub steps: Vec<RecipeStep>,
    #[serde(with = "span_field_wise")]
    pub total_time: jiff::SignedDuration,
    pub visibility: String,

    #[serde(
        default,
        with = "span_field_wise_opt",
        skip_serializing_if = "Option::is_none"
    )]
    pub cook_time: Option<jiff::SignedDuration>,

    #[serde(
        default,
        with = "span_field_wise_opt",
        skip_serializing_if = "Option::is_none"
    )]
    pub prep_time: Option<jiff::SignedDuration>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub referenced: Option<bool>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester_role: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Store)]
pub struct RecipeItem {
    pub id: String,
    pub name: String,
    pub author_name: String,

    #[serde(with = "span_field_wise")]
    pub total_time: jiff::SignedDuration,
}

pub mod span_field_wise {
    use jiff::{SignedDuration, Span, SpanRelativeTo};
    use serde::{self, Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(date: &SignedDuration, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        Span::try_from(*date).unwrap().serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<SignedDuration, D::Error>
    where
        D: Deserializer<'de>,
    {
        let span = Span::deserialize(deserializer)?;

        Ok(span
            .to_duration(SpanRelativeTo::days_are_24_hours())
            .unwrap())
    }
}

pub mod span_field_wise_opt {
    use jiff::{SignedDuration, Span, SpanRelativeTo};
    use serde::{self, Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(date: &Option<SignedDuration>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        date.map(|x| Span::try_from(x).unwrap())
            .serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<SignedDuration>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Option::<Span>::deserialize(deserializer)?
            .map(|x| x.to_duration(SpanRelativeTo::days_are_24_hours()).unwrap()))
    }
}

pub mod traits {
    pub use super::{
        AuthorStoreExt, CapabilityPhaseStoreExt, CapabilitySettingStoreExt,
        ForkedIntoOtherLocaleStoreExt, IngredientAllowedUnitStoreExt, IngredientStoreExt,
        QuantityStoreExt, RecipeIngredientStoreExt, RecipeStepStoreExt, RecipeStoreExt,
        ReferenceCapabilityStoreExt, ReferencePreparationStoreExt, ReferenceSettingStoreExt,
        ReferenceTagStoreExt, ReferenceUnitStoreExt, ReferenceValueStoreExt, SettingValueStoreExt,
        StepCapabilityStoreExt, StepIngredientStoreExt,
    };
}
